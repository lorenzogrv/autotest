
function autoexec () {
  # runs specified test file ensuring test's stdout is valid ATP
  test -x "$1" || fail EACCES "'$1' is not executable"
  # CARE: autotest <FILE> should output valid Autotest Protocol
  {
    ( # run within subshell to catch allways a code
      "$1"
      #code=$?
      #exit $code
    )
    exit $? # exit with catched code to pass through PIPESTATUS
  } | autotext
  TEST_CODE="${PIPESTATUS[0]}" AUTO_CODE="${PIPESTATUS[1]}" TESTSEC=$SECONDS
 
  if (( TEST_CODE + AUTO_CODE == 0 )); then exit 0; fi

  case "$(autocode $AUTO_CODE)" in
    #FAIL) ! (($TEST_CODE)) && exit $(autocode FAIL) ;;
    EAOPEN)
      verb "automatically closing because got EAOPEN"
      printf "CODE "
      (($TEST_CODE)) && printf "%s" $TEST_CODE || printf "%s" $AUTO_CODE
      echo " (generated by $0 $*)"
      ;;
  esac
    
  # now is safe to review the result
  echo "TEST $0" "$@"

  if (($TEST_CODE)); then # test run reported error
    autocode $TEST_CODE &>/dev/null \
      && echo "FAIL test run exit status was $(autocode $TEST_CODE)" \
      || echo "FAIL test run exit status $TEST_CODE is not known by autocode"
    (($TESTSEC < $AUTOSEC)) && printf PASS || printf FAIL
    echo " test run took $TESTSEC seconds (expecting ${AUTOSEC} seconds max)"
    #echo "CODE $TEST_CODE"; exit $TEST_CODE
  else
    echo "PASS test run suceed with exit status 0"
  fi

  if (($AUTO_CODE)); then # autotext reported error
    autocode $AUTO_CODE &>/dev/null \
      && echo "FAIL autotext exit status was $(autocode $AUTO_CODE)" \
      || echo "FAIL autotext exit status $AUTO_CODE is not known by autocode"
  else
    echo "PASS autotext suceed with exit status 0"
  fi

  if (($TEST_CODE == $AUTO_CODE)); then
    echo "PASS test run exit status was $TEST_CODE, expected $AUTO_CODE"
  else
    # CARE must be taken when codes differ, so let's use a case-by-case aproach
    # TODO THIS SHIT IS FUCKING UGLY AND NO ELEGANT, FUCK OFF AND START AGAIN
    if (($TEST_CODE==$(autocode OK))) || (($TEST_CODE==$(autocode SIGPIPE)))
    then
      case "$(autocode $AUTO_CODE)" in
        FAIL) echo "FAIL test run '$1' failed" ;;
        EXCODE) echo "FAIL test run '$1' produced an invalid CODE statement" ;;
        EATEST) echo "FAIL test run '$1' produced invalid ATP syntax" ;;
        EATIME) echo "FAIL test run '$1' timed out"; TEST_CODE=0 ;;
        *) echo "FAIL unexpected autotext exit code $(autocode $AUTO_CODE)" ;;
      esac
    elif (($TEST_CODE==$(autocode ENOENT)))&&(($AUTO_CODE==$(autocode EAVOID)))
    then echo "FAIL file '$1' does not exist"
    elif (($TEST_CODE==$(autocode EACCES)))&&(($AUTO_CODE==$(autocode EAVOID)))
    then echo "FAIL user '$USER' can't execute '$1'"
    elif (($TEST_CODE==$(autocode SIGTERM)))&&(($AUTO_CODE==$(autocode EAOPEN))) \
      || (($TEST_CODE==$(autocode SIGKILL)))&&(($AUTO_CODE==$(autocode EAOPEN)))
    then
      echo "FAIL test run '$1' timed out"
      verb "force EATIME"; TEST_CODE=$(autocode EATIME)
    else
      echo "FAIL code mismatch: $(autocode $TEST_CODE)!=$(autocode $AUTO_CODE)"
      verb "force EACODE"; TEST_CODE=0 AUTO_CODE=$(autocode EACODE)
    fi
  fi

  # if test execution script failed, that's the code to be reported
  printf "CODE "; (($TEST_CODE)) && echo $TEST_CODE || echo $AUTO_CODE

  verb "will exit now, test_code=$TEST_CODE, auto_code=$AUTO_CODE"
  if (($TEST_CODE != 0)); then exit $TEST_CODE; else exit $AUTO_CODE; fi
}

##
# vim modeline (see vim +'help modeline')
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
