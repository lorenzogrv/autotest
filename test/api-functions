#!/bin/bash

# > - Cowboy: Is this really need?
# > - Wiseman: Yes, no tests provide no good features

# test units can't have childs, that's why they are units
# but any test executable may generate more than one test unit

function dry-assert-code () {
    test "${code?:missing actual code}" \
      "${1:?missing operator}" "${2:?missing value}" \
      && pass "code is $@" \
      || fail "code should be $@, but is $code"
}

function dry-diagnose () {
  test -v "${1:?missing output variable name}" || {
    echo "can't diagnose, variable '$1' is not set"
    return 2
  } >&2
  local n=0
  while read l; do
    printf ' %-2s| %s: %s\n' "$n" "${1#std}" "$l"
  done <<<"${!1}" >&2
  code=1
}

function dry-assert-lines () {
  test -v "${1:?missing output variable name}" || {
    echo "$FUNCNAME: variable '$1' is not set"
    return 2
  } >&2

  lines=()
  while read l; do lines+=("$l"); done

  count="$( wc -l <<<"${!1}" )"
  test "$count" -eq "${#lines[@]}" && {
    pass "stdout has ${#lines[@]} data line(s)"
  } || {
    echo FAIL "$case $1 should have ${#lines[@]} data line(s), but has $count"
    dry-diagnose "$1"
    return $?
  }

  local n=0
  while (( n++ < ${#lines[@]} )); do
    expect="${lines[$((n-1))]}"
    read actual
    test "$actual" == "$expect" \
      && pass "$1 line $n is '$expect'" \
      || {
      echo FAIL "$case $1 line $n should be '$expect'"
      printf ' %-2s| %s: %s\n' "$n" "${1#std}" "$actual"
    }
  done <<<"${!1}"
}

function none--test () { :; }

function root--test () {
  # test specified [function_name] outputs the git repository root
	dry-assert-code -eq 0
	test -z "$stderr" && {
		pass "stderr has nothing"
	} || {
		echo "FAIL stderr should have nothing"
		dry-diagnose "stderr"
	}

	dry-assert-lines "stdout" <<-LINES
	$(git rev-parse --show-toplevel)
	LINES
  return $code #to be explicit
}

function pass--test () {
  # tests specified [function_name] echoes PASS "$@" and continues
	dry-assert-code -eq 0
	shift
	dry-assert-lines "stdout" <<-LINES
	PASS $*
	LINES
  return $? #to be explicit
}

function bail--test () {
  # usage: [function_name] [argv]{1,n}
  (
    stdout="$( "$@" &>/dev/null; echo next)"
    code=$?
    dry-assert-code -ne 0
    test "$stdout" = 'next' \
      && fail "function should exit subshell" \
      || { pass "function exits subshell"; code=0; }
    exit $code
  )
  return $? #to be explicit
}

function next--test () {
  # usage: [function_name] [argv]{1,n}
  (
    stdout="$( "$@" &>/dev/null; echo next)"
    code=$?
    dry-assert-code -eq 0
    test "$stdout" != 'next' \
      && fail "function should not exit subshell" \
      || pass "function does not exit subshell"
    exit $code
  )
  return $? #to be explicit
}

function fail--test () {
  # usage: [function_name] [argv]{1,n}
  ( #to avoid pollution
	  func="$1"
		shift

    dry-assert-code -ne 0
    dry-assert-lines "stdout" <<-LINES
		FAIL $*
    CODE 1 by $func @main
		LINES

    case="after calling '$func --next $@'"
    stdout="$( $func --next "$@" 2>/dev/null)"
		code=$?
    dry-assert-code -eq 0
    dry-assert-lines "stdout" <<-LINES
		FAIL $*
		LINES

    exit $code #to be explicit
  )
  return $? #to be explicit
}


case "$1" in
  # any test script must be able to run with no arguments (aka "bare" run)
  '')
    "$0" autotest fail FAIL "should be"
    "$0" autotest bail FAIL "should be"
    "$0" autotest next FAIL --next

    "$0" autotest pass PASS "is"
    "$0" autotest next PASS "is"
  ;;
  # it's often better to use test units to specify the values to be tested
  # instead of using test units to specify the test logic to be executed
  #
  # sharing the test logic between test units eases:
  #   - adding test cases (values to be tested)
  #   - mantaining the test script (less logic = less code = less pain)
  #   - mantaining the test suite tidy (Don't Repeat Yourself)
  #
  # consider writing another test script if logic can't be shared somehow
  *)
    source "$1" || {
      echo "Bad usage: '$1' is not sourceable" >&2
      exit 2
    }
    unit="$2--test"
    test "$(type -t "$unit")" = 'function'|| {
      echo "Bad usage: '$2' is not an unit case" >&2
      exit 2
    }
    # keep in mind: TEST statement specifies how to run the test (command)
    echo "TEST $0 $*"
    
    pass () { echo "PASS $case $@"; }
    bail () { echo "FAIL $case $@"; exit 1; }
    
    case="after sourcing $1, function '$3'"
    test "$(type -t "$1")" = 'function' \
      && pass "is a function" \
      || bail "should be a function"

    fail () { echo "FAIL $case $@"; code=1; }

    shift 2
    case="after calling '$@',"
    stdout="$( "$@" 2>/dev/null)"
    stderr="$( "$@" 2>&1 >/dev/null)"
    code=$?

    $unit "$@"
    code=$?
    echo "CODE $code"
    exit $code
  ;;
  *)
    ;;
esac

##
# vim modeline (see vim +'help modeline')
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
