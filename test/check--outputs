#!/bin/bash

case "$1" in
  '')
    # runs all test cases when no arguments specified
    codes=0 #to know what code to exit
    RUN () { "$0" "all=$1"; }
    for unit in {usage,failure-normal,failure-loudly,success}
      do RUN $unit; codes+=$?
    done
    #report whenever there were failures vía exit code
    test $codes -gt 0
    exit $?
    ;;
  all=?*)
    # runs all cases for specified unit
    unit="${1#all=}"
    codes=0 #to know what code to exit
    CASE () { "$0" "unit=$unit" "$@"; codes+=$?; }

    case "$unit" in
      usage)
        # cases that should fail with code EUSAGE
        CASE : \; --outputs #no arguments at all
        CASE : \; --outputs '' #empty string as first argument
        ;;
      failure-normal)
        # cases that should fail WITHOUT diagnose present on stderr
        unit=failure
        # when command outputs nothing, there is nothing to diagnose
        CASE : \; --outputs something
        CASE : \; --outputs anything #an expressive alias for something
        ;;
      failure-loudly)
        # cases that should fail WITH diagnose present on stderr
        unit=failure
        # diagnose specifies how much lines should be present on stderr
        CASE diagnose=1 echo \; --outputs nothing 
        CASE diagnose=1 printf ' ' \; --outputs nothing 
        CASE diagnose=1 echo foo \; --outputs nothing 
        CASE diagnose=1 echo bar \; --outputs string foo
        CASE diagnose=1 printf foo \; --outputs nothing
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs nothing
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs string a
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs string b
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs string c
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs stdin <<-STDIN
        1
        2
        3
				STDIN
        CASE diagnose=5 printf '%s\n' {1..5} \; --outputs stdin <<-STDIN
        a
        b
        c
				STDIN
        ;;
      success)
        # cases that should succeed and continue execution
        CASE true \; --outputs nothing
        CASE false \; --outputs nothing
        CASE exit 15 \; --outputs nothing
        CASE printf foo \; --outputs something
        CASE echo bar \; --outputs anything
        CASE printf foo \; --outputs string foo
        CASE echo bar \; --outputs string bar #KISS, but should fail instead
        # KISS, but test case above should be instead:
        # CASE echo bar \; --outputs string 'bar\n'
        CASE printf '%s\n' {a..c} \; --outputs stdin <<-STDIN
        a
        b
        c
				STDIN
        ;;
      *)
        echo "Bad usage: no cases for test unit '$unit'"
        exit 2
        ;;
    esac
    #report whenever there were failures vía exit code
    exit $(( $codes ))
    ;;
  unit=?*) ;; # let main() run specified unit
  *)
    echo "Bad usage: '$1' is not a valid test unit" >&2
    exit 2
    ;;
esac

function main () {
  # runs specified unit, gets called at this script end
  unit="${1#unit=}"
  test "$(type -t "$unit")" != 'function' && {
    echo "Bad usage: test unit '$unit' is not defined"
    exit 2
  } >&2
  shift
  
  argv=("$@")
  
  echo "TEST $0 unit=${unit}$(printf " %s" "$@")"

  source autotest
  source "$(autotest--root)/test/dry-assert.bash"
  autotest load check-command
  autotest load check-command--outputs

  if test "$unit" = "failure"; then
    case "$1" in
      diagnose=?*)
        diagnose="${1#diagnose=}"
        shift
        ;;
      *) diagnose=0 ;;
    esac
  fi

  case="check-command"
  stdout="$( check-command "$@" 2>/dev/null )"
  stderr="$( check-command "$@" 2>&1 1>/dev/null )"
  code=$?

  $unit "$@"; code=$?

  echo CODE $code; exit $code
}

function usage () {
  dry-assert-code 2
  dry-refute-output "stdout"
  dry-assert-output "stderr"
  dry-assert-grep-count "stderr" 1 "EUSAGE|usage|invalid"
}


function failure () {
  dry-assert-code 1
  dry-assert-line-count "stdout" 2
  dry-assert-grep-count "stdout" 1 "^FAIL .+"
  dry-assert-grep-count "stdout" 1 "^CODE [0-9]+"  
  # failure cases should exit the subshell execution
  dry-assert-flow-exits check-command "$@"
  if test $diagnose -eq 0; then
    # no diagnose information means no stderr data
    dry-refute-output "stderr"
  else
    # diagnose information presence tests
    dry-assert-output "stderr"
    dry-assert-line-count "stderr" $diagnose
    dry-assert-grep-count "stderr" $diagnose "^([0-9]| ){3}\| (1|2)> .*$"
  fi
}

function success () {
  dry-assert-code 0
  dry-refute-output "stderr"
  dry-assert-line-count "stdout" 1
  dry-assert-grep-count "stdout" 1 "^PASS .+"
}

main "$@"

##
# vim modeline
# Vim: set filetype=sh ts=2 shiftwidth=2 expandtab:
