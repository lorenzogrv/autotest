#!/bin/bash

case "$1" in
  --help|help|-h)
    echo "usage: $0 # runs all test cases"
    echo "       $0 all=[CASES] # runs [CASES] group"
    exit 0
    ;;
  '')
    # runs all test cases when no arguments specified
    codes=0 #to know what code to exit
    RUN () { "$0" "all=$1"; }
    for unit in {OK,FAIL-quiet,FAIL-loud,EUSAGE,ENOENT}
      do RUN $unit; codes+=$?
    done
    #report whenever there were failures vía exit code
    test $codes -gt 0
    exit $?
    ;;
  all=?*)
    # runs all cases for specified unit
    unit="${1#all=}"
    codes=0 #to know what code to exit
    source autotest;
    run="$(autotest--root)/test/check-command"
    run="${run/$PWD/.}"
    CASE () { "$run" unit=$unit load=outputs "$@"; codes+=$?; }

    case "$unit" in
      EUSAGE)
        # cases that should fail with code EUSAGE
        CASE : \; --outputs #no arguments at all
        CASE : \; --outputs '' #empty string as first argument
        CASE : \; --outputs stdin <<<'' #empty stdin
        CASE : \; --outputs string #missing string parameter
        CASE : \; --outputs string {1..2} #to much string parameters
        ;;
      ENOENT)
        # cases that could fail with code ENOENT (command not found)
        # > this may happen for bad quoted argvs, or unexistant commands
        # but must be reported as FAIL (and include diagnose) because:
        # 1. they output nothing to stdout but there is something on stderr
        CASE diagnose=1 this-cmd-does-not-exist \; --outputs nothing
        CASE diagnose=1 "echo foo" \; --outputs nothing
        # 2. they output something to stderr but nothing to stdout
        CASE diagnose=1 this-cmd-does-not-exist \; --outputs something
        CASE diagnose=1 "echo foo" \; --outputs something
        ;;
      FAIL-quiet)
        # cases that should fail WITHOUT diagnose present on stderr
        # when command outputs nothing, there is nothing to diagnose
        unit=FAIL
        CASE : \; --outputs something
        CASE : \; --outputs anything
        CASE printf \; --outputs error
        ;;
      FAIL-loud)
        # cases that should fail WITH diagnose present on stderr
        unit=FAIL
        # diagnose specifies how much lines should be present on stderr
        CASE diagnose=1 echo \; --outputs nothing 
        CASE diagnose=1 printf ' ' \; --outputs nothing 
        CASE diagnose=1 echo foo \; --outputs nothing 
        CASE diagnose=1 echo bar \; --outputs string foo
        CASE diagnose=1 printf foo \; --outputs nothing
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs nothing
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs string a
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs string b
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs string c
        CASE diagnose=5 printf '%s\n' {1..5} \; --outputs stdin <<<$'a\nb\nc'
        # care, use :set expandtab for HERE docs and ident with tabs
        CASE diagnose=3 printf '%s\n' {a..c} \; --outputs stdin <<-STDIN
				1
				2
				3
				STDIN
        CASE diagnose=1 echo \; --outputs error
        CASE diagnose=1 printf foo \; --outputs error
        CASE diagnose=7 printf '%s\n' {1..7} \; --outputs error
        ;;
      OK)
        # cases that should succeed and continue execution
        CASE true \; --outputs nothing
        CASE false \; --outputs nothing
        CASE printf foo \; --outputs something
        CASE echo bar \; --outputs anything
        CASE printf foo \; --outputs string foo
        CASE : \; --outputs string '' # empty string is ok, unlike stdin
        # when command outputs nothing, it's OK even if code is ENOENT
        CASE exit 127 \; --outputs nothing
        # of course it's OK for other codes
        CASE exit 15 \; --outputs nothing
        # KISS, but the following should fail
        CASE echo bar \; --outputs string bar
        # KISS, but test case above should be instead:
        #CASE echo bar \; --outputs string $'bar\n'
        CASE printf '%s\n' {a..c} \; --outputs stdin <<<$'a\nb\nc'
        CASE unexistant-command \; --outputs error
        ;;
      *)
        echo "Bad usage: no cases for test unit '$unit'"
        exit 2
        ;;
    esac
    #report whenever there were failures vía exit code
    test $codes -gt 0
    exit $?
    ;;
  *)
    echo "Bad usage: '$1' is not a valid test unit" >&2
    exit 2
    ;;
esac

##
# vim modeline
# Vim: set filetype=sh ts=2 shiftwidth=2 expandtab:
