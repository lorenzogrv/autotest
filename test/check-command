#!/bin/bash

case "$1" in
  --help|help|-h)
    echo "usage: $0 # runs all test cases"
    echo "       $0 all=[CASES] # runs [CASES] group"
    exit 0
    ;;
  '')
    # runs all test cases when no arguments specified
    codes=0 #to know what code to exit
    RUN () { "$0" "all=$1"; }
    for unit in {OK,FAIL-quiet,FAIL-loud,EUSAGE,ENOENT}
      do RUN $unit; codes+=$?
    done
    #report whenever there were failures vía exit code
    test $codes -gt 0
    exit $?
    ;;
  all=?*)
    # runs all cases for specified unit
    unit="${1#all=}"
    codes=0 #to know what code to exit
    CASE () { "$0" "unit=$unit" "$@"; codes+=$?; }

    case "$unit" in
      *)
        echo "Bad usage: no cases for test unit '$unit'"
        exit 2
        ;;
    esac
    #report whenever there were failures vía exit code
    test $codes -gt 0
    exit $?
    ;;
  unit=?*) ;; # let main() run specified unit
  *)
    echo "Bad usage: '$1' is not a valid test unit" >&2
    exit 2
    ;;
esac

function main () {
  # runs specified unit, gets called at this script end
  unit="${1#unit=}"
  case $unit in ENOENT|EUSAGE|FAIL|OK) ;; *)
    echo "Bad usage: test unit '$unit' is not defined"
    exit 2
  esac
  
  test -t 0 && stdin="" || stdin="$(cat)"

  echo "TEST ${0}$(printf " %q" "$@") <<<$(printf %q "${stdin}")"
  shift # unit=* argument

  source autotest
  source "$(autotest--root)/test/dry-assert.bash"
  autotest load check-command
  autotest load check-command--outputs

  #while $#
  case "$1" in
    diagnose=?*) diagnose="${1#diagnose=}"; shift ;;
    *) diagnose=0 ;;
  esac

  case="check-command"
  stdout="$( check-command "$@" <<<"$stdin" 2>/dev/null )"
  stderr="$( check-command "$@" <<<"$stdin" 2>&1 1>/dev/null )"
  code=$?

  case $unit in
    OK)
      test $diagnose -eq 0 || {
        echo "> Remember:"
        echo "> succesful commands should never write data to stderr"
        diagnose=0
      } >&2
      expect_code=0
      dry-assert-line-count "stdout" 1
      dry-assert-grep-count "stdout" 1 "^PASS .+"
      ;;
    FAIL)
      expect_code=1
      dry-assert-line-count "stdout" 2
      dry-assert-grep-count "stdout" 1 "^FAIL .+"
      dry-assert-grep-count "stdout" 1 "^CODE [0-9]+"  
      ;;
    EUSAGE)
      test $diagnose -eq 0 || {
        echo "> Remember:"
        echo "> bad usage failures should write no diagnose, but usage error"
        diagnose=0
      } >&2
      expect_code=2
      dry-refute-output "stdout"
      dry-assert-grep-count "stderr" 1 "EUSAGE|usage|invalid"
      ;;
    ENOENT)
      test $diagnose -eq 1 || {
        echo "> Remember:"
        echo "> not-found commands should write exactly one diagnose line"
        diagnose=1
      } >&2
      expect_code=1 # see cases coments
      dry-assert-line-count "stdout" 2 # be loud, include stdout
      dry-assert-grep-count "stdout" 1 "^FAIL .+"
      dry-assert-grep-count "stdout" 1 "^CODE 1( .+)?"  
      dry-assert-grep-count "stderr" 1 "ENOENT|not found|no encontrada"
      ;;
  esac

  if test $diagnose -eq 0; then
    # no diagnose information means no stderr data except for EUSAGE because
    # stderr is not diagnosing the command BUT the check-command call itself
    test $expect_code -ne 2 && dry-refute-output "stderr"
  else
    # diagnose information presence tests
    dry-assert-output "stderr"
    # when there is stdin data, it should be present at diagnose
    test -n "$stdin" && input=$(wc -l <<<"$stdin") || input=0
    dry-assert-line-count "stderr" $((diagnose+input))
    dry-assert-grep-count "stderr" $diagnose "^([0-9]| ){3}\| (1|2)> .* <"
    dry-assert-grep-count "stderr" $input "^([0-9]| ){3}\| 0< .* >$"
  fi
  
  dry-assert-code $expect_code

  if test $expect_code -gt 0; then
    # any non-success case should exit the subshell execution
    dry-assert-flow-exits check-command "$@" <<<"$stdin"
  else
    # but any success case should continue
    dry-assert-flow-continues check-command "$@" <<<"$stdin"
  fi

  # if reaches here, assume test succeed
  echo CODE 0 #implicit return 0
}

main "$@"

##
# vim modeline
# Vim: set filetype=sh ts=2 shiftwidth=2 expandtab:
