#!/bin/bash

source autotest

function dry-diagnose () {
  test -v "${1:?missing output variable name}" || {
    echo "can't diagnose, variable '$1' is not set"
    return 2
  } >&2
  local n=0
  while read l; do
    printf ' %-2s| %s: %s\n' "$((++n))" "${1#std}" "$l"
  done <<<"${!1}" >&2
  code=1
}

function dry-assert-failure () {
  desc="${2:?missing failure description}"
  case="${case%,} ($desc),"
  test $code -eq "${1:?'missing expected code'}" && {
    PASS "$case code is $code"
    code=0
  } || {
    FAIL --next "$case code should be $1, but is $code"
    (($code > 0 )) || code=1
  }
  test -z "$stdout" && {
    PASS "$case stdout has no data"
  } || {
    FAIL --next "$case stdout should have no data"
    dry-diagnose "stdout"
  }
  test -n "$stderr" && {
    PASS "$case stderr has some data"
  } || {
    FAIL "$case stderr has no data"
  }
  grep "$desc" <<<"$stderr" &>/dev/null && {
    PASS "$case gracefully fails containing '$desc'"
  } || {
    FAIL --next "$case should contain '$desc'"
    dry-diagnose "stderr"
  }
  return $code
}

function dry-assert-equal () {
  local value="${3:?missing value description}"
  test "$1" = "$2" && {
    PASS "$case $value ($1) is equal to '$2'"
  } || {
    FAIL --next "$case $value should be '$2', but is '$1'"
    {
      printf '   | cmd[@]: '
      printf " '%s'" "${cmd[@]}"
      printf \\n
    } >&2
    return 1
  }
}

function dry-assert-line-count () {
  test -v "${1:?missing output variable name}" || {
    echo "$FUNCNAME: variable '$1' is not set"
    return 2
  } >&2

  count="$( wc -l <<<"${!1}" )"
  test "$count" -eq "${2:?missing expected line count}" && {
    PASS "$case $1 has $2 data line(s)"
  } || {
    FAIL --next "$case $1 should have $2 data line(s), but has $count"
    dry-diagnose "$1"
    return 1
  }
}

case $# in
  0)
    # run all test units
    root="$(git rev-parse --show-toplevel)"

    file="$root/api/check-command.bash" 
    "$root/test/all-bash-source" "$file" || exit

    "$0" "" #to trigger missing arguments, empty string must be specified
    
    for cmd in {:,true,false}; do
      "$0" "$cmd" # no assertions
      "$0" "$cmd" --unexistant #plugin
      "$0" "$cmd" --arguments # no arguments is acceptable
    done

    "$0" {1..5} --arguments {a..d}
    "$0" {1..2} --arguments {a..f}
    "$0" {1..3} --arguments '' # is acceptable?
    "$0" {1..4} --arguments -- # double dash is acceptable
    "$0" {1..5} --arguments a -b ! -- # double dash is acceptable

    exit $?
    ;;
  *)
    # run specified test unit
    {
      source autotest #--debug
      autotest load "check-command"
    } || {
      echo "$0: can't load test dependencies"
      exit 127
    } >&2

    function quit () { echo CODE $code; exit $code; }

    cmd=("check-command" "$@") 

    shift
    echo "TEST $0 '${cmd[1]}' $@"
   
    case="after running,"
    stdout="$( "${cmd[@]}" 2>/dev/null )"
    stderr="$( "${cmd[@]}" 2>&1 1>/dev/null )"
    code=$?

    case "${cmd[@]:1}" in
      '') dry-assert-failure 2 "missing arguments"; quit ;;
      *--unexistant*) dry-assert-failure 127 "unexistant plugin"; quit ;;
      *--arguments*)
        check-command--arguments () {
          was_run () { :; }; export -f was_run
          dry-assert-equal $# $(( ${#cmd[@]}-1 )) 'plugin arity ($#)' || {
            verb "arguments are '$@'" >&2
          }
          local n=1
          until test "${!n}" = '-command'; do
            (( ++n < $# )) || {
              echo "FAIL $case plugin should receive -command parameter"
              return 1
            }
          done
          local c=0; while (( ++c < $n )); do
            dry-assert-equal "${!c}" "${cmd[ ${#cmd[@]}-$n+$c ]}" "plugin \$$c"
          done
          dry-assert-equal "${!n}" "-command" 'plugin $'$n
          local a=0; while (( ++a <= $n )) && (( c++ < $# )); do
            dry-assert-equal "${!c}" "${cmd[ $a ]}" "plugin \$$c"
          done
        }
        ;;
      *--variables*)
        check-command--variables () {
          was_run () { :; }; export -f was_run
          dry-assert-equal \
            "$(( ${#AUTOPLUG[@]} + ${#AUTOCMD[@]} ))" \
            "$#"  "number of arguments"
        }
        ;;
      *--?*)
        echo "$0: no test unit for argv '$*'" >&2
        exit 1
        ;;
      *) dry-assert-failure 2 "no assertions specified"; quit ;;
    esac

    stdout="$( "${cmd[@]}" 2>/dev/null )"
    stderr="$( "${cmd[@]}" 2>&1 1>/dev/null )"
    code=$?

    (
      "${cmd[@]}" &>/dev/null
      test "$(type -t was_run)" = 'function' && {
        PASS "$case plugin function has been executed"
      } || {
        FAIL "$case plugin function should have been executed"
      }
    )

    case "${cmd[@]:1}" in
      *--arguments*)
        dry-assert-line-count "stdout" $(( ${#cmd[@]} ))
        dry-assert-line-count "stderr" 0
        ;;
      *--variables*)
        dry-assert-line-count "stdout" 1
        dry-assert-line-count "stderr" 0
        egrep '^PASS' <<<"$stdout" &>/dev/null && {
          PASS "$case plugin assertion succeeds"
        } || {
          FAIL --next "$case plugin assertion should succeed"
          dry-diagnose "stdout"
          code=1
        }
        ;;
    esac

    echo "CODE $code"
    exit $code

  ;;
esac

function check-command--example-plugin () {
  function was_run () { :; }; export -f was_run
  dry-assert-equal "$2" 4
  dry-assert-equal "${AUTOPLUG[2]}" 4
  dry-assert-equal "$3" "b c"
  dry-assert-equal "${AUTOPLUG[3]}" "b c"
  dry-assert-equal "$4" "-key"
  dry-assert-equal "${AUTOPLUG[4]}" "-key"
  dry-assert-equal "$5" "val"
  dry-assert-equal "${AUTOPLUG[5]}" "val"
  dry-assert-equal "$6" "--"
  dry-assert-equal "$7" "true"
  echo "$FUNCNAME stdout"
  echo "$FUNCNAME stderr" >&2
  return 43
}

case="when specified the --example-plugin,"
check-command 'true' --example-plugin "a" 4 "b c" -key val &>/dev/null
test "$(type -t was_run)" = 'function' && {
  PASS "$case plugin function gets executed"
} || {
  FAIL "$case plugin function was not executed"
}
output="$(
  check-command 'true' --example-plugin "a" 4 "b c" -key val 2>/dev/null
)"
code=$?
test $code -eq 43 && {
  PASS "plugin return value is preserved $case"
} || {
  FAIL "should preserve return code 43 $case but returns $code instead"
}
grep -q stdout <<<"$output" && {
  PASS "plugin stdout gets captured the usual way"
} || {
  FAIL "expected plugin stdout to contain the string 'stdout'"
}
! grep -q stderr <<<"$output" && {
  PASS "plugin stderr gets ignored the usual way"
} || {
  FAIL "expected plugin stdout to NOT contain the string 'stderr'"
}

echo "CODE 0"

##
# vim modeline
# Vim: set filetype=sh ts=2 shiftwidth=2 expandtab:
