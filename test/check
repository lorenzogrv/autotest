#!/bin/bash

case "$1" in
  '')
    # run all test units

    #cases=() #that should be considered EUSAGE
    "$0" "unit=EUSAGE" # no arguments at all
    "$0" "unit=EUSAGE" "" # empty string as arguments
    "$0" "unit=EUSAGE" "true" # no assertion options (but command exists)
    "$0" "unit=EUSAGE" "true" --unexistant #plugin (but command exists)

    #cases=() #that should be considered ENOENT
    "$0" "unit=ENOENT" "true" \; --unexistant #plugin
    "$0" "unit=ENOENT" "bad-command" \; --unexistant #plugin

    # special care must be taken with multiple-parametized commands
    "$0" "unit=EUSAGE" {1..5} --noop
    "$0" "unit=EUSAGE" {y..z} -- --noop
    "$0" "unit=EUSAGE" {1..3} --noop
    "$0" "unit=EUSAGE" {1..7} \! --noop
    "$0" "unit=EUSAGE" {h..k} \+ --noop
    
    #cases() #that should succeed
    "$0" "unit=OK" "true" \; --noop # plugins may accept no arguments
    "$0" "unit=OK" "bad-command" \; --noop #127 command may be a test!
    "$0" "unit=OK" ":" \; --noop --void --lines 0
    "$0" "unit=OK" 'echo' {1..4} \; --noop --params 5 --lines 1
    "$0" "unit=OK" 'printf' '%s\n' {a..c} \; --noop --params 5 --lines 3
    "$0" "unit=OK" echo foo bar \; --lines 1 --exact "foo bar"
   
    #cases() #that should fail WITHOUT diagnose present on stderr 
    "$0" "unit=FAIL" ":" \; --lines 1

    #cases() #that should fail WITH diagnose present on stderr 
    "$0" "unit=DIAG" "echo" something \; --void
    "$0" "unit=DIAG" "echo foo" \; --void #command "echo foo" is not found
    
    exit $?
    ;;
  unit=*) ;;
  *)
    echo "$1" is not a valid test unit >&2
    exit 2
    ;;
esac

function main () {
  # run specified test unit
  source autotest #--debug
  source "$(autotest--root)/test/dry-assert.bash"
  autotest load "check-command"

  unit="unit${1#unit=}"
  
  test "$(type -t "$unit")" != "function" && {
    echo "Test unit '$unit' is not defined here" >&2
    exit 2
  }

  echo "TEST $0" "$( printf " '%s'" "$@" )"
  shift
  cmd=("check-command" "$@") 

  # define some plugins for testing purposes
  # does nothing
  check-command--noop () {
    case="running inside $FUNCNAME for '${AUTOCMD[@]}'"
    echo "PASS plugin $FUNCNAME received $# arguments"
    echo "PASS plugin $FUNCNAME is awesome"
  }
  # asserts AUTOCMD array length is N
  check-command--params () {
    case="$case, inside plugin $FUNCNAME"
    #this should receive one param
    dry-assert-equality "${#AUTOPLUG[@]}" 2 "AUTOPLUG length"
    dry-assert-equality "${#AUTOCMD[@]}" "$1" "AUTOCMD length"
  }
  # refutes command stdout and stderr
  check-command--void () {
    case="$case, running '${AUTOCMD[@]}' inside $FUNCNAME"
    #should receive no params (autoplug length 1)
    dry-assert-equality "${AUTOPLUG[@]}" "$FUNCNAME"
    local output="$( "${AUTOCMD[@]}" 2>&1 )"
    dry-refute-output "output" "$1"
  }
  # asserts command succeeds and its stdout has N lines
  check-command--lines () {
    case="$case, running '${AUTOCMD[@]}' from $FUNCNAME"
    output="$( "${AUTOCMD[@]}" 2>/dev/null )"
    code=$?
    dry-assert-code 0
    dry-assert-line-count "output" "$1"
  }
  # asserts command succeeds and its stdout is exact to STRING
  check-command--exact () {
    case="$case, running '${AUTOCMD[@]}' from $FUNCNAME"
    output="$( "${AUTOCMD[@]}" 2>/dev/null )"
    code=$?
    dry-assert-code 0
    dry-assert-equality "$output" "$1"
  }
  
  plugin_count=0
  for arg in "$@"; do case "$arg" in 
    #KISS, don't test multi-param commands with this long options
    --noop|--params|--void|--lines|--exact) 
  let plugin_count++;; esac; done
   
  case="while running check-command"

  stdout="$( "${cmd[@]}" 2>/dev/null )"
  stderr="$( "${cmd[@]}" 2>&1 1>/dev/null )"
  code=$?
  
  case="at $unit,"

  $unit "$@" #run the unit
  code=$?

  echo "CODE $code"
  exit $code
}

function failure () {
  desc="${2:?missing failure description}"
  dry-assert-code "${1:?'missing expected code'}"
  dry-refute-output "stdout"
  dry-assert-output "stderr"
  dry-assert-grep-count "stderr" 1 "$desc"
  code=0
  return $code
}

function unitEUSAGE () { failure 2 "EUSAGE|usage|invalid"; }
function unitENOENT () { failure 127 "ENOENT|does not exist"; }

function unitOK () {
  dry-assert-code 0
  # each test-purpose plugin draws 2 assertions
  dry-assert-output "stdout"
  dry-assert-line-count "stdout" "$(( plugin_count*2 ))"
  # if it's success, every line should be PASS
  dry-assert-grep-count "stdout" "$(( plugin_count*2 ))" "^PASS .+"
  # if it's success, stderr should be empty
  dry-refute-output "stderr"
}

function fail-common () {
  dry-assert-code 1
  dry-assert-output "stdout"
  # if it's code FAIL, it must provide at least one FAIL and one CODE
  dry-assert-grep-count "stdout" 1 "^FAIL .+"
  dry-assert-grep-count "stdout" 1 "^CODE .+"
}
function unitFAIL () {
  fail-common
  # KISS: use this unit for FAIL cases with no diagnose on stderr
  dry-refute-output "stderr"
}
function unitDIAG () {
  fail-common
  # KISS: use this unit for FAIL cases with diagnose on stderr
  dry-assert-output "stderr"
}

main "$@"; exit $?

function check-command--example-plugin () {
  return 43
}

output="$(
  check-command 'true' --example-plugin "a" 4 "b c" -key val 2>/dev/null
)"
code=$?
test $code -eq 43 && {
  PASS "plugin return value is preserved $case"
} || {
  FAIL "should preserve return code 43 $case but returns $code instead"
}


##
# vim modeline
# Vim: set filetype=sh ts=2 shiftwidth=2 expandtab:
