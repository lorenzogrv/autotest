#!/bin/bash

source autotest

autotest load check-command
autotest load check-command--returns

function dry-assert-code () {
  test "$code" -eq $1 && {
    PASS "code is $1 when $case"
  } || {
    FAIL --next "code should be $1 when $case, but returns $code"
  }
}
function dry-diagnose () {
  test -v "${1:?missing output variable name}"
  while read l; do
    echo "   | ${1#std}: $l"
  done <<<"${!1}" >&2
  code=1
}
function dry-assert-output () {
  test -v "${1:?missing output variable name}"
  test -n "${!1}" && {
    PASS "$1 has data when $case"
  } || {
    FAIL --next "$1 should have data when $case"
    return 1
  }
}
function dry-refute-output () {
  test -v "${1:?missing output variable name}"
  test -z "${!1}" && {
    PASS "$1 has no data when $case"
  } || {
    FAIL --next "$1 should have no data when $case"
    dry-diagnose "$1"
    return 1
  }
}

function usage () {
  dry-assert-code 2
  dry-refute-output "stdout"
  dry-assert-output "stderr" || return
  egrep "EUSAGE|usage|invalid" <<<"$stderr" &>/dev/null && {
    PASS "it gracefully fails when $case"
  } || {
    FAIL --next "stderr tells nothing about usage error"
    dry-diagnose "stderr"
  }
}

function failure () {
  dry-assert-code 1
  dry-refute-output "stderr"
  test $(wc -l <<<"$stdout") -eq 1 &&  {
    PASS "outputs exactly ONE line on stdout when $case"
  } || {
    FAIL --next "should output exactly ONE line on stdout when $case"
    dry-diagnose "stdout"
  }
  egrep -q "^FAIL .+" <<<"$stdout" >/dev/null && {
    PASS "stdout contains the FAIL statement when $case"
  } || {
    FAIL --next "stdout should contain the FAIL statement when $case"
    dry-diagnose "stdout"
  }
}

function success () {
  dry-assert-code 0
  dry-refute-output "stderr"
  test $(wc -l <<<"$stdout") -eq 1 &&  {
    PASS "outputs exactly ONE line on stdout when $case"
  } || {
    FAIL --next "should output exactly ONE line on stdout when $case"
    dry-diagnose "stdout"
  }
  egrep -q "^PASS .+" <<<"$stdout" >/dev/null && {
    PASS "stdout contains the PASS statement when $case"
  } || {
    FAIL --next "stdout should contain the PASS statement when $case"
    dry-diagnose "stdout"
  }
}

case "$1" in
  # run all test cases
  '')
    $0 usage ": --returns" "missing [value]"
    $0 usage ": --returns ''" "[value] is empty string"

    $0 failure "false --returns zero" \
      "[value] is 'zero', command is false"
    $0 failure "true --returns non-zero" \
      "[value] is 'non-zero', command is true"
    $0 failure "true --returns nonzero" \
      "[value] is 'nonzero', command is true"
    $0 failure "false --returns 13" \
      "[value] is '13', command is false"
    $0 failure "true --returns 51" \
      "[value] is '51', command is true"

    $0 success "true --returns zero" \
      "[value] is 'zero', command is true"
    $0 success "false --returns non-zero" \
      "[value] is 'non-zero', command is true"
    $0 success "false --returns nonzero" \
      "[value] is 'nonzero', command is true"
    $0 success "exit 13 --returns 13" \
      "[value] is '13', command is 'exit 13'"
    $0 success "exit 3 --returns -lt 5" \
      "[value] is '-lt 5', command is 'exit 3'"
    ;;
  dry-*)
    echo "Bad usage: '$1' is not a valid test unit" >&2
    exit 2
    ;;
  *)
    unit="$1"
    test "$(type -t "$unit")" != 'function' && {
      echo "Bad usage: test unit '$unit' is not defined"
      exit 2
    } >&2
    
    shift
    argv="${1:?missing check-command argument list}"
    case="${2:?missing $unit case description}"

    stdout="$( check-command $argv 2>/dev/null )"
    stderr="$( check-command $argv 2>&1 >/dev/null )"
    code=$?

    echo "TEST $0 $unit '$argv' '$case'"
    $unit "$@"
    code=$?
    echo CODE $code
    exit $code
    ;;
esac

function dry-assert-equal () {
  test "$1" = "$2" && {
    PASS "value '$1' is equal to '$2'"
  } || {
    caller 0 >&2
    FAIL "actual value is '$1' but expected it to be '$2'"
  }
}

##
# vim modeline
# Vim: set filetype=sh ts=2 shiftwidth=2 expandtab:
