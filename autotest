#!/bin/bash

autotest--help () {
  cat <<HELP
Usage:

  - 'autotest': prints all autotest code on stdout
  - 'autotest checkup': runs the autotest test suite
  - 'autotest <SCRIPT>': runs <SCRIPT> after sourcing autotest code
  - 'autotest report <SCRIPT>': execs SCRIPT, discarding stderr, but
                                generated output is guaranted to be
                                valid AutoTest Protocol data.

  Any other value at argument 1 outputs this help text.

  Code examples:

  - 'source <(autotest)': sources the autotest code for later usage
  - 'autotest checkup && source <(autotest) || exit': common way to assert
    the toolset work as expected before sourcing it
HELP
}

# outputs the autotest root directory
function autotest--root () { dirname "$(realpath "$0")"; }

# outputs all autotest code to stdout
# TODO testodo <<<"tool to report tests pending to write"
function autotest--code () {
  find "$(autotest--root)" -name "*.bash" -type f -exec cat '{}' +
}

# autotest code is sent to stdout when this script receives 0 arguments
(( $# )) || { autotest--code; exit $?; }

# given a file as argument 1, autotest behaves as test-runner
if (( $# == 1 )) && test -f "$1"
then
  source <(autotest--code)
  echo "TEST $1"
  SECONDS=0 # TODO better time measure
  (exec "$1") # exec the file within a subshell to catch allways a code
  code=$?
  echo "CODE $code IN ${SECONDS}s";
  exit $code # preserve the exit code from test execution
fi

case "$1" in
  root) autotest--root; exit ;;
  checkup)
    # TODO replace this and use 1 file and {brace,expansion} instead?
    find "$(autotest--root)" -name "*.bash" -type f -exec bash -c '
      file={}
      tool=${file##*/}
      tool=${tool%%.bash}
      source "$file" || exit
      test "$(type -t ${tool}--test)" = "function" || {
        echo "\"$tool--test\" should be a function defined in $file"
        exit 1
      }
      $tool--test
    ' \;
    source <(autotest)
    tested "autotest can be sourced with process substitution"
    exit $?
    ;;
  report) ;; # defined after
  *) autotest--help; test $1 == "help"; exit $? ;;
esac

##
# THE AUTOTEST PROTOCOL (ATP)
#
# TODO write something about
# TODO missing the IN keyword on current implementation
##

# Tells whenever given value ($1) is an integer
is_int () { case "${1#[-]}" in ''|*[!0-9]*) return 1;; *) return 0;; esac; }

# pass-through stdin data to stdout, but ensure its syntax matches ATP
function autotest--protocol.v1 () {
  local tlvl=0 clvl=0 fifo='passtrought' return=0
  while read keyword value; do
    case $keyword in
      TEST)
        if ! test -f "$value"; then
          emsg "EATEST: '$value' is not a file"; return=3; break
        fi
        if test $tlvl -eq $clvl; then let tlvl++; else
          emsg "EATEST: expecting CODE before TEST"; return=4; break
        fi
        ;;
      PASS|FAIL|SKIP) : ;;
      CODE)
        if ! is_int "$value" && test $value -lt 256; then
          emsg "EATEST: invalid code ($value)"; return=3; break
        fi
        if test $clvl -lt $tlvl; then let clvl++; else
          emsg "EATEST: expecting TEST before CODE"; return=4; break
        fi
        ;;
      *) emsg "EATEST: bad syntax: '$keyword $value'"; return=2; break ;;
    esac
    echo "$keyword $value" # pass data down through pipeline
  done
  test $return -gt 0 && return $return
  test $tlvl -gt 0 || emsg "EATEST: expecting at least one TEST" && return 5
  test $tlvl -eq $clvl || emsg "EATEST: expecting final CODE" && return 6
}

# helper to fail fast
function autofail () { echo >&2 "${1:?'missing message'}"; exit ${2:-1}; }

# trick (ugly) to use bashidos' log utils emsg here
function emsg () { echo "$@" >&2; }

##
# REPORT ROUTINE
##

test $# -eq 2 || autofail "expecting two arguments"
test -f "$2" || autofail "'$2' is not a file"
# exec the file within a subshell to catch allways a code
{ echo "TEST $2"; (exec "$2"); code=$?; echo "CODE $code"; exit $code; } \
  2>/dev/null | autotest--protocol.v1
# generate report discarding all stderr
# pipe to autotest--protocol validates output data
exit $PIPESTATUS # report exit code must be the test exit code

##
# vim modeline (see vim +'help modeline')
# vim: expandtab filetype=sh ts=2 shiftwidth=2
