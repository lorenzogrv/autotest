#!/bin/bash

function autotest--root () {
  # outputs the autotest root directory
  AUTOTEST_ROOT="$(dirname "$(readlink -f "$BASH_SOURCE")")"
  autotest--root () { echo "$AUTOTEST_ROOT"; }
  autotest--root
}

# this is done early because no more source code is need to perform this task
if test "$0" = "$BASH_SOURCE" && ! (( $# ))
then
  # output all autotest old-api source code to stdout
  find "$(autotest--root)/old-api" -name "*.bash" -type f -exec cat '{}' +
  exit $?
fi
  
function emsg () { echo "autotest:" "$@"; } >&2 # better than >&2 echo
function verb () { :; } # meant for debugging
if test "$1" = '--debug'; then
  function verb () { emsg "debug: $(caller 0):" "$@"; }
fi
function fail () {
  # helper to fail fast
  code=$(autocode "${1:?'missing exit code'}") || exit
  emsg "$1: ${2:?'missing message'}"
  exit $code
}

if test "$0" = "$BASH_SOURCE"
then
  #
  # assume autotest is being executed
  #
  
  # some subcomands can be run now to speed-up them
  case "$1" in
    help|-h|--help)
      source "$(autotest--root)/README.sh" "$@";
      exit $?
      ;;
    root) autotest--root; exit ;;
  esac

  source "$(autotest--root)/api/autocode.bash"
  # run autocode subcommand ASAP to speed it up a bit
  case "$1" in code) shift; autocode "$@"; exit; esac

  source "$(autotest--root)/api/autotext.bash"
  # this subcommands can be run here to speed' em up a bit
  case "$*" in
    -) autotext; exit ;;
    'report '*)
      test $# -ge 2 || fail "expecting at least 2 arguments" 2
      test -f "$2" || fail "'$2' is not a file" 127
      ## generate report discarding all stderr
      "$0" "$2" "${@:3}" 2>/dev/null
      exit $? # preserve report exit status
      ;;
  esac

  # TEST RUNNER USAGE: <FILE> [ARG .. LIST] should be handled here
  source "$(autotest--root)/api/autoexec.bash"
  test -f "$1" && { autoexec "$@"; exit $?; }

  # when $1 is not a file neither a subcommand, fail with ENOENT
  emsg "ENOENT: '$1' is not a subcommand, neither a file"
  emsg "try '$(basename "$0") help' for ussage information"
  exit $(autocode ENOENT)

##
##
  case "$1" in
    checkup)
      # TODO define after, this should be refactored
      # TODO replace this and use 1 file and {brace,expansion} instead?
      find "$(autotest--root)/old-api" -name "*.bash" -type f -exec bash -c '
        file={}
        tool=${file##*/}
        tool=${tool%%.bash}
        source "$file" || exit
        test "$(type -t ${tool}--test)" = "function" || {
          echo "\"$tool--test\" should be a function defined in $file"
          exit 1
        }
        $tool--test
      ' \;
      source <(autotest)
      tested "autotest can be sourced with process substitution"
      exit $?
      ;;
  esac

else
  #
  # assume autotest is being sourced
  #
  
  source "$(autotest--root)/api/autotest.bash"
  return $? # source should return true, but may not
fi


##
# TRASHCAN HEREAFTER
##

    # here come edirection trick? => NO, WRITE TESTS FIRST FKIN COWBOY
    #autotest "$2"  2>/dev/null | autotest--protocol.v1 2>/dev/null
    #UNIT="" TEST=""
    #while read KEY VALUE
    #do # "semantic" validation
    #  if test "$KEY" == "TEST"; then TEST="$VALUE"; UNIT=""; fi
    #  UNIT="$(printf '%s%s\n' "$UNIT" "$KEY $VALUE")"
    #  test "$KEY" != "CODE" && echo "$KEY $VALUE" && continue
    #  # perform the validation
    #  if ! { diff -y -W 80 --left-column --color=auto \
    #       <(autotest $TEST 2>/dev/null) - <<<"$UNIT"
    #     } >&2
    #  then # unit is not semantically correct
    #    exit 99
    #  fi
    #done < <


##
# vim modeline (see vim +'help modeline')
# /* vim: set expandtab: */
# /* vim: set filetype=sh ts=2 shiftwidth=2: */
